% Set the author and title of the compiled pdf
\hypersetup{
	pdftitle = {\Title},
	pdfauthor = {\Author}
}

\section{Terminology}

In order to talk about Strings in any meaningful way, we must first define
terminology that we can use to describe exactly what we mean. What follows is a
list of the terminology used throughout the course:

\begin{itemize}
	\item A {\bf symbol} is basically a letter. They are the basic component of
	all the data we use in the course. Examples include: {\it a, A, (, \$, 7}.
	\item An {\bf alphabet} is a collection of symbols that we can think of as a
	set. Example alphabets may include binary ({\it 0, 1}), Latin letters ({\it
	a,\dots,z,A,\dots,Z}) etc.
	\item A {\bf String} is a collection of symbols from an alphabet grouped
	together, sometimes	called a word. Examples include {\it ababa} and
	{\it 100101}.
	\item The {\it empty word} is a String consisting of no symbols. It is
	denoted by the letter $\epsilon$.
	\item {\bf Concentration} an operation that takes two Strings and combines
	them to create one longer String. For example concentrating {\it t} and {\it
	he} would create {\it the}. We can use the power notation to concentrate a
	String with itself any number of times. For example, ${ho}^3$ would give us
	$hohoho$.
	\item A {\bf language} is a collection of Strings that can be thought of as
	a set. Examples of languages could be $\{\emptyset\}$, $\{\epsilon\}$,
	$\{hot,hotter,hottest\}$ or $\{a^n | n \in \mathbb{N}\}$.
\end{itemize}

We also have notation for describing generic instances of such entities:

\begin{center}
	\begin{tabular}{l l}
		{\bf Entity} & {\bf Generic notation}\\
		Symbol & $x, y, z$\\
		Alphabet & $\Sigma$\\
		String & $s, t, u$\\
		Language & $\mathcal{L}$\\
	\end{tabular}
\end{center}

\paragraph{Languages as sets} Since languages are thought of as sets, we can
perform all the usual set operations on them (see my {\tt COMP11120} notes for
more information on these operations). Languages can be concentrated as
described above.

Sometimes, we may want to define any finite number of concatenations of a
language, and this is known as the {\bf Kleene star}. The notation is
$(\mathcal{L})^*$.

An interesting case of this is when a languages is subject to concatenation zero
times ($\mathcal{L}^0$), since this would return the empty word $\epsilon$.

\marginpar{{\it Kleene} is pronounced like {\it genie}.}

\section{Describing languages}

\subsection{Describing languages through patterns}

A pattern describes a generic form that a set of Strings can take. If any String
from the set is compared with the pattern then it will match the pattern. Any
String from outside the set will not match the pattern.

For example, the pattern $(ab)^*$ would match Strings such as $\epsilon$, $ab$,
$abab$, $abab \dots ab$.

\marginpar{$\epsilon$ is matched here since it satisfies the pattern $(ab)^0$.
This comes about because, the Kleene star matches all concatenations of a
String.}

\subsection{Regular expressions}

The terms {\it pattern} and {\it regular expression} are pretty much synonymous.
The operators allowed in a regular expression are:

\begin{center}
	\begin{tabular}{>{\bfseries} l l}
		Empty pattern & The character $\emptyset$ is a pattern.\\
		Empty word & The character $\epsilon$ is a pattern.\\
		Letters & Every letter in $\Sigma$ is a pattern.\\
		\rowcolor{Gray}
		Concatenation & If $x$ and $y$ are patterns, then so is $(xy)$.\\
		\rowcolor{Gray}
		Alternative & If $x$ and $y$ are patterns, then so is $(x|y)$.\\
		\rowcolor{Gray}
		Kleene Star & If $x$ is a pattern, then so is $(x^*)$.
	\end{tabular}
\end{center}

\marginpar{If we were to analyse a pattern in a recursive fashion, then in order
to end our analysis, we would eventually have to find one of a selection of {\it
base cases}.The highlighted rows here represent {\it step cases} (that is to say
that at least another level of recursion is needed to finish our analysis),
while the un-highlighted lines are base cases.}

\subsubsection{Discarding brackets}

Just like in high-school mathematics, brackets can be discarded when unnecessary. For example, the pattern $((0|1)^*0)$ is equivalent to $(0|1)^*0$, and $(2|(1|0))$ is the same as $(2|1|0)$.

\subsubsection{Matching a regular expression}

As was implied above, we can define a regular expression by recursively
applying more operators to a `base case' until we have the desired pattern.

The following patterns match the following words:

\begin{center}
	\begin{tabularx}{\textwidth}{>{\bfseries} l X}
		Empty word 		& The empty word only matches the pattern $\epsilon$.\\
		Base case 		& A pattern $x$ will match a character $x$ where $x$ is
						  a member of $\Sigma$\\
		Concatenation 	& If $p_1$ is a pattern and $p_2$ is a pattern, then
						  $p_1p_2$ will match any word matched by $p_1$
						  prepended to and word matched by $p_2$\\
		Alternative 	& $(p_1|p_2)$ will match a word from either $p_1$ or 
						  $p_2$.\\
		Kleene star 	& The pattern $(p^*)$ will match any number of words
						  that are matched by $p$ concatenated with each other.
						  It also matches the empty word.\\
	\end{tabularx}
\end{center}

\subsection*{Languages described by regular expressions}

A language $\mathcal{L}$ described by a regular expression $p$ is one made up of
every word $s$ that is matched by $p$:

\[
	\mathcal{L}(p) - \{s \in \Sigma^* | s~matches~p\}
\]

Obviously, we can describe the same language using different patterns, for
example:

\[
	\mathcal{L}((1|1)(0|0)) = \mathcal{L}(10)
\]

We can find out the exact language defined by a pattern in the following manner:

\[
	\begin{split}
		\mathcal{L}((0|1)(1)^*) &= \mathcal{L}(0|1) \cdot \mathcal{L}(1^*)\\
								&= \mathcal{L}(0) \cup \mathcal{L}(1) \cdot \mathcal{L}(1^*)\\
								&= \mathcal{L}(0) \cup \mathcal{L}(1) \cdot \mathcal{L}(1)^*\\
								&= \{0\} \cup \{1\} \cdot \mathcal{L}(1)^*\\
								&= \{0\} \cup \{1\} \cdot \{1\}^*\\
	\end{split}
\]

\subsubsection*{Regular languages}

We say that a language is regular if we can describe the language by defining a
regular expression.

\section*{Finite State Automata}

It is often useful to be able to describe languages using pictures. These are
called finite state automata (FSA's). Every FSA must have the following things:

\begin{itemize}
	\item One or more states.
	\item Arrows between states with labels directing the required conditions to
		  traverse the arrow.
	\item A start state (indicated by an arrow with it's tail free).
	\item One or more accepting states. If we end up here after traversing the
		  automation, then it will match our word.
\end{itemize}

\subsection*{Example automata}

Here is an automata that will match the pattern $0(0|1)0$:

\begin{center}
	\includegraphics{automata/1.pdf}
\end{center}

If we wanted to, we could include all the {\it dump states} in the automata.
Dump states are states that once entered into, it is impossible to reach an
accepting state. The same automata with a dump state in would look like:

\begin{center}
	\includegraphics{automata/2.pdf}
\end{center}

\subsection*{Formalising the automata}

If we wanted to, we could define the set $Q$ as the set of states in an
automata, and the set $F$ as the set of the accepting states, where $F \subset
Q$. The transitions in the automata could be represented as a function $\delta$,
which takes an input state $s_{in} \in Q$, and a character $c \in \Sigma$, and
returns another state $s_{out} \in Q$.

\[
	\delta:\{(s_{in},c)| s_{in} \in Q, c \in \Sigma\} \rightarrow Q
\]

\marginpar{When an automata is defined like this, it can be seen as a {\it finite
state machine}}

\subsection*{Deterministic and non-deterministic automata}

An automata is said to be deterministic if there is only one path through it for
every word in $\mathcal{L}$, however, if there are multiple possible routes
through an automata (i.e. there is no unique path for one or more words), then
we say that the automata is non-deterministic.

Here is an example of a deterministic and a non-deterministic automata that will
accept the language of words defined by the pattern $(0|1)^*(11)$:

\begin{center}
	\includegraphics{automata/3.pdf}
\end{center}

\begin{center}
	\includegraphics{automata/4.pdf}
\end{center}