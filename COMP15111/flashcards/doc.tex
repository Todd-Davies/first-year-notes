\documentclass[frontgrid]{flacards}
\usepackage{tabularx}
\usepackage{color}


\definecolor{light-gray}{gray}{0.75}

\newcommand{\frontcard}[1]{\textcolor{light-gray}{\colorbox{light-gray}{$#1$}}}
\newcommand{\backcard}[1]{#1} 

\newcommand{\flashcard}[1]{% create new command for cards with blanks
    \card{% call the original \card command with twice the same argument (#1)
        \let\blank\frontcard% but let \blank behave like \frontcard the first time
        #1
    }{%
        \let\blank\backcard% and like \backcard the second time
        #1
    }%
}

\begin{document}

\pagesetup{2}{4} 

\card{
	Where do the values that are fed into an operand come from when an
	instruction is executed using the three address style?
}{
	Memory.
	\vspace{1em}\\
	The resulting value is also copied to a destination address in memory.
}

\card{
	Why are registers faster than memory?
}{
	\begin{tabularx}{0.5\textwidth}{l X}
		- & Implemented using a flip flop or some other very fast volatile
		storage (rather than smaller, cheaper SRAM).\\
		- & Situated inside the processor, so there's less distance for the
		data to travel, which takes less time.\\
		- & Fewer of them so address decoding takes less time\\
		- & Data doesn't need to be transferred over a bus.\\
	\end{tabularx}
}

\card{
	What is the {\it one-address} style of instruction?
}{
	Where only one memory address may be used in any one instruction. The other
	operands must be registers.
}

\card{
	Describe the {\it load-store} style of instruction.
}{
	The only operations on memory are load and store operations. This means each
	instruction is very fast and very simple, but there are many instructions.
}

\card{
	How is code written in ARM Assembly run?
}{
	It is first assembled using an assembler into machine code. Then it is
	loaded into memory and executed sequentially.
}

\card{
	What is the instruction to load a value at a memory address into a register?
}{
	{\tt LDR <register> <memory\_address\_alias>}
}

\card{
	What is the instruction to store a value in a register to a memory address?
}{
	{\tt STR <register> <memory\_address\_alias>}
}

\card{
	What is the instruction to sum two numbers?
}{
	{\tt ADD <destination\_register> <operand\_register1> <operand\_register2>}
}

\card{
	What is the instruction to branch upon a condition?
}{
	{\tt B <condition> <branch\_name>}
}

\card{
	What does the program counter do? What register is it?
}{
	It is used to store the memory address of the next instruction to be executed.
	\vspace{1em}\\
	It's register 15.
}

\card{
	When is the {\tt DEFW} command executed. What does it do? What's its syntax?
}{
	It is executed before the program runs.
	\vspace{1em}\\
	It stores a value at a memory address and assigns the address an alias.
	\vspace{1em}\\
	{\tt <alias> DEFW <value\_1>, ... <value\_n>}
}

\card{
	What does {\tt DEFB} do?
}{
    {\tt DEFB} stores a single byte in memory. If you give it a string, the
	whole string will be stored (in multiple bytes).
}

\card{
	What's the syntax of {\it DEFS}?
}{
	{\tt <alias> DEFS <number\_of\_bytes>, <value\_of\_bytes>}
}

\card{
	What does {\tt STRB} do? What is it's syntax?
}{
	Stores the lowest eight bits of a register into memory.
	\vspace{1em}\\
	{\tt STRB <register> <memory\_alias>}
}

\card{
	What does {\tt LDRB} do? What is it's syntax?
}{
	Loads the lowest eight bits of a specific memory address into a register. 
	The other bits in the register are set to zero.
	\vspace{1em}\\
	{\tt LDRB <register> <memory\_alias>}
}

\flashcard{When using Little Endian, bytes are read from \blank{left} to \blank{right}.}

\flashcard{When using Big Endian, bytes are read from \blank{right} to \blank{left}.}

\card{How many bits are assigned to a literal in an ARM instruction}{12}

\card{
	What command should be used to load a literal into a {\it register}
}{
	{\tt LDR <register> =<literal>}
	\vspace{1em}\\
	Note, this is a pseudo instruction, that is converted to either {\tt MOV
	<register> \#<literal>} or it will define a constant and load that in from
	memory.
}

\card{
	How do you load an address into a register so you can use it as a pointer?
}{
	{\tt ADR <register>, <alias>}
	Now the {\tt <register>} will hold the memory location (and is therefore a
	pointer to) the alias.
}

\card{
	What does {\tt DEFW <number>} do?
}{
	It reserves a word of memory initialised to {\tt <number>}
}

\card{
	What does {\tt DEFB <value>} do?
}{
	It reserves a byte(s) of memory with the value {\tt <value>}. If a string is
	passed as the value, multiple bytes will be reserved, each with the value of
	a character.
}

\card{
	What does {\tt DEFS <size>, <fill>} do?
}{
    It reserves a block of memory {\tt <size>} bytes long initialised to the
	value {\tt <fill>}.
}

\card{
	What does {\tt ALIGN} do?
}{
	Leaves blank bytes in memory so that the next {\tt DEFINE} command will 
	start on a word boundary.
}

\card{
	What does {\tt ENTRY} do?
}{
	Sets the PC at the start of the program (i.e. dictates where the program
	should) start from.
}

\card{
	What does {\tt EQU} do?
}{
	{\tt EQU} allows us to name a literal. You can then refer to the literal 
	(still with a hash before it) by name in your code which is easy to read.
	\vspace{1em}\\
	{\tt <alias> EQU \#<value>}
}

\card{
	What are the four status flags provided by the ARM architecture?
}{
	\begin{tabularx}{0.5\textwidth}{l X}
		- & Negative\\
		- & Zero\\
		- & Carry\\
		- & Overflow\\
	\end{tabularx}
}

\card{
	How can you combine a CMP instruction with another instruction?
}{
	Append {\tt S} to an instruction. E.g.:\\
	{\tt SUBS R0, R1, R2}\\
	If the result in {\tt R0} was negative, then the negative flag would be set
	etc etc.
}

\card{
	What does {\tt RSB} do?
}{
	Reverse subtract. {\tt RSB R1, R0, \#0}:\\
	{\tt R1 = 0 - R0 = -R0}
}

\card{
	What does {\tt MLA} do?
}{
	Multiply and add. {\tt MLA R0, R1, R2, R3}:\\
	{\tt R0 = (R0 * R1) + R2}
}

% Look at my decoy \phantoms mwahaha!

\flashcard{
	\begin{tabularx}{0.4\textwidth}{l X}
		Condition code & Meaning (for cmp or subs)\\ \hline
		eq & \blank{Equal \phantom{1234567891011121314}}\\
		ne & \blank{Not equal \phantom{123456789101112}}\\
		ge & \blank{Signed greater than or equal}\\
		le & \blank{Signed less than or equal \phantom{12}}\\
		lt & \blank{Signed less than \phantom{123456}}\\
		gt & \blank{Signed greater than \phantom{1234}}\\
	\end{tabularx}
}

% -------------------
% Methods of addressing
% -------------------
\card{
	In the following instruction, what method of addressing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR R0, [R1]}
}{
	This is called {\bf register-indirect addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1}.
	\\\vspace{2em}
	{\tt R1} won't be altered at all.
}

\card{
	In the following instruction, what method of addressing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, \#4]}
}{
	This is called {\bf pre-indexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + 4}.
	\\\vspace{2em}
	{\tt R1} won't be altered at all.
}

\card{
	In the following instruction, what method of addressing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, \#4]!}
}{
	This is called {\bf pre-indexed autoindexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + 4}.
	\\\vspace{2em}
	{\tt R1} will be incremented by {\tt 4} {\it before} the load operation.
}

\card{
	In the following instruction, what method of addressing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1], \#4}
}{
	This is called {\bf post-indexed autoindexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + 4}.
	\\\vspace{2em}
	{\tt R1} will be incremented by {\tt 4} {\it after} the load operation.
}

\card{
	In the following instruction, what method of addressing is used, what will
	{\tt R0} contain and what will happen to {\tt R1} and {\tt R2}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, R2]}
}{
	This is called {\bf register-indexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + R2}.
	\\\vspace{2em}
	{\tt R1} and {\tt R2} will stay the same.
}

\card{
	In the following instruction, what method of addressing is used, what will
	{\tt R0} contain and what will happen to {\tt R1} and {\tt R2}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, R2, LSL, \#2]}
}{
	This is called {\bf scaled register-indexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + (R2 * 4)}.
	\\\vspace{2em}
	{\tt R1} and {\tt R2} will stay the same.
}

% ---------------
% Strings
% ---------------

\card{
	How do you load a String into a register?
}{
	\begin{tabularx}{0.5\textwidth}{X}
		{\tt msg DEFB "Hello"}\\
		{\tt ALIGN}\\
		{\tt ADRL R0, msg}\\
		{\tt SVC 3}
	\end{tabularx}
}

\card{
	What does the {\tt ADRL} instruction do?	
}{
	It is a psudo instruction that loads a program relative address into the
	register. It is compiled into two {\tt ADD} instructions.
}

\card{
	How do you find the length of a string defined by the alias {\tt message}?
}{
	\begin{tabularx}{0.5\textwidth}{X}
		{\tt 	ADRL R1, message}\\
		{\tt 	MOV R2, \#0}\\
		{\tt count LDRB R0, [R1, R2]}\\
		{\tt 	CMP R0, \#0}\\
		{\tt 	ADDNE R2, R2, \#1}\\
		{\tt 	BNE count}\\
		{\tt 	STR R2, length}
	\end{tabularx}
}

\card{
	What are the four ARM bit shifting/rotation instructions?
}{
	\begin{tabularx}{0.4\textwidth}{l X}
		{\bf Mnemonic} & {\bf Meaning} \\

		{\tt LSL} & Logical shift left \\

		{\tt LSR} & Logical shift right \\

		{\tt ASR} & Arithmetic shift right\\

		{\tt ROR} & Rotate Right
	\end{tabularx}
}

\card{
	What is the syntax of a shifting or rotation operation in ARM?
}{
	{\tt INSTRUCTION destination operand (\#)shift}
}

\card{
	How can {\tt LSL} be used to load words from a table/array in memory?
}{
	{\tt LDR R0, [R1, R2, LSL #2]
}

% --------
% Stacks
% --------



\end{document} 
